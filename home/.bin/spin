#!/usr/bin/env node

const child_process = require("child_process");

// adb shell dumpsys window
main(1080, 2400).catch((err) => {
  console.error("error:", err.message);
  process.exit(1);
});

async function main(width, height) {
  const times = randomBetween(3, 5);

  for (let i = 0; i < times; i++) {
    await swipeRandom(
      width / 4,
      height / 2,
      (3 * width) / 4,
      height / 2,
      width / 16,
      randomBetween(100, 200),
    );

    await sleep(randomBetween(50, 100));
  }
}

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function swipeRandom(fx, fy, tx, ty, r, ms) {
  const from = randomPoint(fx, fy, r, r);
  const to = randomPoint(tx, ty, r, r);
  return swipeExact(from.x, from.y, to.x, to.y, ms);
}

function swipeExact(fx, fy, tx, ty, ms) {
  return adb("shell", "input", "swipe", fx, fy, tx, ty, ms);
}

function adb(...args) {
  return new Promise((resolve, reject) => {
    const proc = child_process.spawn("adb", args, {
      stdio: "inherit",
    });

    proc.on("data", (data) => process.stdout.write(data));
    proc.on("error", reject);
    proc.on("exit", (code) =>
      code ? reject(new Error("the adb exited with code " + code)) : resolve(),
    );
  });
}

function randomPoint(cx, cy, hw, hh) {
  return {
    x: randomBetween(cx - hw, cx + hw),
    y: randomBetween(cy - hh, cy + hh),
  };
}

function randomBetween(min, max) {
  return Math.floor(min + Math.random() * (max - min));
}
