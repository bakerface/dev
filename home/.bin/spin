#!/usr/bin/env node

const child_process = require("child_process");

main().catch((err) => {
  console.error("error:", err.message);
  process.exit(1);
});

async function main() {
  const [width, height] = await getScreenDimensions();
  const times = randomBetween(3, 5);

  for (let i = 0; i < times; i++) {
    await swipeRandom(
      width / 4,
      height / 2,
      (3 * width) / 4,
      height / 2,
      width / 16,
      randomBetween(100, 200),
    );

    await sleep(randomBetween(50, 100));
  }
}

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

function swipeRandom(fx, fy, tx, ty, r, ms) {
  const from = randomPoint(fx, fy, r, r);
  const to = randomPoint(tx, ty, r, r);
  return swipeExact(from.x, from.y, to.x, to.y, ms);
}

function swipeExact(fx, fy, tx, ty, ms) {
  return adb("shell", "input", "swipe", fx, fy, tx, ty, ms);
}

async function getScreenDimensions() {
  const stdout = await adb("shell", "dumpsys", "window");
  const match = stdout.match(/displayWidth=(\d\d+) displayHeight=(\d\d+)/);

  if (!match) {
    console.log(stdout);
    throw new Error("Unable to get the screen dimensions");
  }

  return match.slice(1).map(Number);
}

function adb(...args) {
  return new Promise((resolve, reject) => {
    let stdout = "";
    const proc = child_process.spawn("adb", args);

    proc.stdout.on("data", (data) => {
      stdout += data;
    });

    proc.on("error", reject);

    proc.on("exit", (code) =>
      code
        ? reject(new Error("the adb exited with code " + code))
        : resolve(stdout),
    );
  });
}

function randomPoint(cx, cy, hw, hh) {
  return {
    x: randomBetween(cx - hw, cx + hw),
    y: randomBetween(cy - hh, cy + hh),
  };
}

function randomBetween(min, max) {
  return Math.floor(min + Math.random() * (max - min));
}
